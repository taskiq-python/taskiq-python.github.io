import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as a,a as t}from"./app.15c27472.js";const o={},n=t(`<h1 id="cli" tabindex="-1"><a class="header-anchor" href="#cli" aria-hidden="true">#</a> CLI</h1><p>Core library comes with CLI programm called <code>taskiq</code>, which is used to run workers.</p><p>To run it you have to specify the broker you want to use and modules with defined tasks. Like this:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>taskiq mybroker:broker_var my_project.module1 my_project.module2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="autoimporting" tabindex="-1"><a class="header-anchor" href="#autoimporting" aria-hidden="true">#</a> Autoimporting</h2><p>Enumerating all modules with tasks is not an option sometimes. That&#39;s why taskiq can autodiscover tasks in current directory recursively.</p><p>We have two options for this:</p><ul><li><code>--tasks-pattern</code> or <code>-tp</code>. It&#39;s a name of files to import. By default is searches for all <code>tasks.py</code> files.</li><li><code>--fs-discover</code> or <code>-fsd</code>. This option enables search of task files in current directory recursively, using the given pattern.</li></ul><h2 id="type-casts" tabindex="-1"><a class="header-anchor" href="#type-casts" aria-hidden="true">#</a> Type casts</h2><p>One of features taskiq have is automatic type casts. For examle you have a type-hinted task like this:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">task</span><span class="token punctuation">(</span>val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> val <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>If you&#39;ll call <code>task.kiq(&quot;2&quot;)</code> you&#39;ll get 3 as the returned value. Because we parse signatures of tasks and cast incoming parameters to target types. If type-cast fails you won&#39;t throw any error. It just leave the value as is. That functionality allows you to use pydantic models, or dataclasses as the input parameters.</p><p>To disable this pass the <code>--no-parse</code> option to the taskiq.</p><h2 id="hot-reload" tabindex="-1"><a class="header-anchor" href="#hot-reload" aria-hidden="true">#</a> Hot reload</h2><p>This is annoying to restart workers every time you modify tasks. That&#39;s why taskiq supports hot-reload. To enable this option simply pass the <code>--reload</code> or <code>-r</code> option to taskiq CLI.</p><p>Also this option supports <code>.gitignore</code> files. If you have such files in your directory. It won&#39;t reload worker, if you cange ignored file&#39;s contents. To disable this functionality pass <code>--do-not-use-gitignore</code> option.</p>`,16),i=[n];function r(c,d){return s(),a("div",null,i)}const u=e(o,[["render",r],["__file","cli.html.vue"]]);export{u as default};
