import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as n,b as i,d as r,w as d,a as s,e,r as c}from"./app.9b8508a6.js";const l={},p=s(`<h1 id="cli" tabindex="-1"><a class="header-anchor" href="#cli" aria-hidden="true">#</a> CLI</h1><p>Core library comes with CLI programm called <code>taskiq</code>, which is used to run different subcommands.</p><p>By default taskiq is shipped with only two commands: <code>worker</code> and <code>scheduler</code>. You can search for more taskiq plugins using pypi. Some plugins may add new commands to taskiq.</p><h2 id="worker" tabindex="-1"><a class="header-anchor" href="#worker" aria-hidden="true">#</a> Worker</h2><p>To run worker process, you have to specify the broker you want to use and modules with defined tasks. Like this:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>taskiq worker mybroker:broker_var my_project.module1 my_project.module2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="autoimporting" tabindex="-1"><a class="header-anchor" href="#autoimporting" aria-hidden="true">#</a> Autoimporting</h3><p>Enumerating all modules with tasks is not an option sometimes. That&#39;s why taskiq can autodiscover tasks in current directory recursively.</p><p>We have two options for this:</p><ul><li><code>--tasks-pattern</code> or <code>-tp</code>. It&#39;s a name of files to import. By default is searches for all <code>tasks.py</code> files.</li><li><code>--fs-discover</code> or <code>-fsd</code>. This option enables search of task files in current directory recursively, using the given pattern.</li></ul><h3 id="type-casts" tabindex="-1"><a class="header-anchor" href="#type-casts" aria-hidden="true">#</a> Type casts</h3><p>One of features taskiq have is automatic type casts. For examle you have a type-hinted task like this:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">task</span><span class="token punctuation">(</span>val<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> val <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>If you&#39;ll call <code>task.kiq(&quot;2&quot;)</code> you&#39;ll get 3 as the returned value. Because we parse signatures of tasks and cast incoming parameters to target types. If type-cast fails you won&#39;t throw any error. It just leave the value as is. That functionality allows you to use pydantic models, or dataclasses as the input parameters.</p><p>To disable this pass the <code>--no-parse</code> option to the taskiq.</p><h3 id="hot-reload" tabindex="-1"><a class="header-anchor" href="#hot-reload" aria-hidden="true">#</a> Hot reload</h3><p>This is annoying to restart workers every time you modify tasks. That&#39;s why taskiq supports hot-reload. To enable this option simply pass the <code>--reload</code> or <code>-r</code> option to taskiq CLI.</p><p>Also this option supports <code>.gitignore</code> files. If you have such files in your directory. It won&#39;t reload worker, if you cange ignored file&#39;s contents. To disable this functionality pass <code>--do-not-use-gitignore</code> option.</p><h2 id="scheduler" tabindex="-1"><a class="header-anchor" href="#scheduler" aria-hidden="true">#</a> Scheduler</h2>`,19),u=e("Scheduler is used to schedule tasks as described in "),h=e("Scheduling tasks"),m=e(" section."),k=s(`<p>To run it simply run</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>taskiq scheduler &lt;path to scheduler&gt; [optional module to import]...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>For example</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>taskiq scheduler my_project<span class="token punctuation">.</span>broker<span class="token punctuation">:</span>scheduler my_project<span class="token punctuation">.</span>module1 my_project<span class="token punctuation">.</span>module2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="parameters" tabindex="-1"><a class="header-anchor" href="#parameters" aria-hidden="true">#</a> Parameters</h3><p>Path to scheduler is the only required argument.</p><ul><li><code>--tasks-pattern</code> or <code>-tp</code>. It&#39;s a name of files to import. By default is searches for all <code>tasks.py</code> files.</li><li><code>--fs-discover</code> or <code>-fsd</code>. This option enables search of task files in current directory recursively, using the given pattern.</li><li><code>--log-level</code> is used to set a log level.</li></ul>`,7);function y(f,v){const a=c("RouterLink");return o(),n("div",null,[p,i("p",null,[u,r(a,{to:"/guide/scheduling-tasks.html"},{default:d(()=>[h]),_:1}),m]),k])}const _=t(l,[["render",y],["__file","cli.html.vue"]]);export{_ as default};
